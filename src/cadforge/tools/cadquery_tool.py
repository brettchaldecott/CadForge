"""CadQuery tool handler â€” execute CadQuery code and export results."""

from __future__ import annotations

from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from cadforge.cad.sandbox import execute_cadquery
from cadforge.utils.paths import (
    get_scripts_output_dir,
    get_stl_output_dir,
    get_step_output_dir,
)


def _save_source_code(
    project_root: Path,
    code: str,
    output_name: str,
    output_path: Path,
) -> Path:
    """Save the CadQuery source code alongside the exported model.

    Returns the path to the saved script.
    """
    scripts_dir = get_scripts_output_dir(project_root)
    script_path = scripts_dir / f"{output_name}.py"

    header = (
        f'"""CadQuery script: {output_name}\n'
        f"\n"
        f"Generated by CadForge on {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}\n"
        f"Output: {output_path.name}\n"
        f'"""\n\n'
        f"import cadquery as cq\n"
        f"import numpy as np\n\n"
    )

    # Only add the header if the code doesn't already import cadquery
    if "import cadquery" in code or "from cadquery" in code:
        full_code = code
    else:
        full_code = header + code

    script_path.write_text(full_code, encoding="utf-8")
    return script_path


def handle_execute_cadquery(
    tool_input: dict[str, Any],
    project_root: Path,
) -> dict[str, Any]:
    """Execute CadQuery code and optionally export the result."""
    code = tool_input["code"]
    output_name = tool_input.get("output_name", "model")
    fmt = tool_input.get("format", "stl")

    if fmt == "step":
        output_dir = get_step_output_dir(project_root)
        output_path = output_dir / f"{output_name}.step"
    else:
        output_dir = get_stl_output_dir(project_root)
        output_path = output_dir / f"{output_name}.stl"

    result = execute_cadquery(code, output_path=output_path)

    if not result.success:
        return {
            "success": False,
            "error": result.error,
            "stdout": result.stdout,
            "stderr": result.stderr,
        }

    response: dict[str, Any] = {
        "success": True,
        "stdout": result.stdout,
    }

    if result.has_workpiece:
        # Save source code alongside the model
        script_path = _save_source_code(project_root, code, output_name, output_path)

        response["output_path"] = str(output_path)
        response["script_path"] = str(script_path)
        response["message"] = (
            f"Model exported to {output_path}\n"
            f"Source code saved to {script_path}"
        )
    else:
        response["message"] = "Code executed successfully (no result variable set)"

    return response
